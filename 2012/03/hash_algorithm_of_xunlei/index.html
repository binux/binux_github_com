<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>迅雷Hash算法分析 | Binuxの杂货铺</title>
  <meta name="author" content="Roy Binux">
  
  <meta name="description" content="从迅雷离线获得的地址中，存在着大量的Hash值，这些hash看似都是base64,sha1,md5但却有所不同。比如这是一个典型的离线地址
http://gdl.lixian.vip.xunlei.com/download?
fid=3KUoDlBy9IotAFn5vQAHc5VUIgKiwSgmA">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="迅雷Hash算法分析"/>
  <meta property="og:site_name" content="Binuxの杂货铺"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
    <link rel="alternate" href="/atom.xml" title="Binuxの杂货铺" type="application/atom+xml">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-36392342-1', 'auto');
	ga('send', 'pageview');

</script>


<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Binuxの杂货铺</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/projects">Projects</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-hash_algorithm_of_xunlei" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2012-03-25T20:46:57.000Z"><a href="/2012/03/hash_algorithm_of_xunlei/">2012-03-25</a></time>
      
      
  
    <h1 class="p-name title" itemprop="headline name">迅雷Hash算法分析</h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>从迅雷离线获得的地址中，存在着大量的Hash值，这些hash看似都是base64,sha1,md5但却有所不同。<br>比如这是一个典型的离线地址</p>
<pre><code>http://gdl.lixian.vip.xunlei.com/download?
fid=3KUoDlBy9IotAFn5vQAHc5VUIgKiwSgmAAAAAHYA3duVUUeWgaJI4JGu5syK9PLK&amp;     // base64: 与cid,size,gcid相关(size为小字节序)
mid=666&amp;                                        // maybe: always 666
threshold=150&amp;                                  // maybe: always 150
tid=A950BAE38A2E7398186D4127315DB76F            // unknow: 256bit relate with size
srcid=4                                         // maybe: always 4
verno=1                                         // maybe: always 1
g=7600DDDB9551479681A248E091AEE6CC8AF4F2CA&amp;     // gcid: for normal download gcid == cid
scn=c7&amp;                                         // section
i=3547930B96AFA7B0A1CFCC80D516ADE97A34DAE0&amp;     // cid == infoid == btih == ed2k hash, files share a same cid in a bt task, cid is the btih of the torrent
t=6&amp;                                            // type: 1=normal 4=ed2k 6=bt
ui=18×××9640&amp;                                  //userid
ti=33742×××247&amp;                                //tid from get free url
s=640205218&amp;                                    //totalByte
m=0&amp;                                            // mayby: always 0
n=01324486025B4775690D459D7F43726F770F6CBF6F345D5B46347DA817445D5B422876D1025B783236556EA51C335D2E6D0A47E45F00000000     // filename
</code></pre>
<p>根据已有的数据分析&#x2F;比对，大致各个字段的含义已经标识出来了。其中除了ui,ti是与用户相关的变元，cid是来源相关的变元，其他的字段对于某一个文件来说一般是相同的。</p>
<h2 id="cid"><a href="#cid" class="headerlink" title="cid"></a>cid</h2><p>算法源码：</p>
<pre><code>def cid_hash_file(path):
    h = hashlib.sha1()
    size = os.path.getsize(path)
    with open(path, &#39;rb&#39;) as stream:
        if size &lt; 0xF000:
            h.update(stream.read())
        else:
            h.update(stream.read(0x5000))
            stream.seek(size/3)
            h.update(stream.read(0x5000))
            stream.seek(size-0x5000)
            h.update(stream.read(0x5000))
    return h.hexdigest().upper()
</code></pre>
<p>算法来自于<a target="_blank" rel="noopener" href="https://github.com/iambus/xunlei-lixian">https://github.com/iambus/xunlei-lixian</a>。<br>在api中，cid主要用于文件的索引。观察代码可知，cid并没有hash整个文件，而是根据文件的头&#x2F;中&#x2F;尾部的0x5000字节的内容计算Hash。这样就可以在不下载完整个文件，就能够查询到其他服务器上可能的相同文件。于是在下载支持range的文件的时候，即使该地址没有被索引到，但是通过cid，依旧可以被p2sp加速。<br>当然了，由于没有hash整个文件，文件在事实上有可能是不同的，那么根据下面这个gcid就可以唯一确定一个文件了。</p>
<h2 id="gcid"><a href="#gcid" class="headerlink" title="gcid"></a>gcid</h2><pre><code>def gcid_hash_file(path):
    h = hashlib.sha1()
    size = os.path.getsize(path)
    psize = 0x40000
    while size / psize &gt; 0x200 and psize &lt; 0x200000:
        psize = psize &lt;&lt; 1
    with open(path, &#39;rb&#39;) as stream:
        data = stream.read(psize)
        while data:
            h.update(hashlib.sha1(data).digest())
            data = stream.read(psize)
    return h.hexdigest().upper()
</code></pre>
<p>这个算法是我完全没有通过逆向黑盒分析而来，虽然没有做完整的测试，但是一般来说是正确的。。分析借助了loli.lu的18万个已有文件的数据，以及<a target="_blank" rel="noopener" href="http://coffee.xunlei.com:8000/viewthread.php?tid=692&extra=page=1">迅雷咖啡吧</a>上的一句话：“如果文件很大，则计算gcid非常耗时，因此可以在大文件传输过程中计算gcid，文件传输完毕，则gcid也计算好了“。。<br>gcid的作用是文件的唯一键，在迅雷服务器上唯一确定一个文件。可以说，只要有了gcid，实际上是可以任意下载到需要的文件的。算法采用了分片hash再二次sha1的算法。。猜测原因是因为分片被限制在512个一下，当hash较大文件的时候，可以边下载边hash，再在最后hash那个不到512*20字节的串即可，当文件下载完成的时候就能立即得出gcid。还有一个原因是bt文件也是用sha1分片Hash的，那么获得种子文件也就同时有可能获得gcid了。同时，如果迅雷服务器保存了每个分片的sha1 hash的话，那么在下载通过cid匹配的文件同时，就能同时比较各个分片是否正确，以此保证最终结果。</p>
<h2 id="fid"><a href="#fid" class="headerlink" title="fid"></a>fid</h2><p>算法如下：</p>
<pre><code>def parse_fid(fid):
    cid, size, gcid = struct.unpack(&quot;&lt;20sq20s&quot;, fid.decode(&quot;base64&quot;))
    return cid.encode(&quot;hex&quot;).upper(), size, gcid.encode(&quot;hex&quot;).upper()

def gen_fid(cid, size, gcid):
    return struct.pack(&quot;&lt;20sq20s&quot;, cid.decode(&quot;hex&quot;), size, gcid.decode(&quot;hex&quot;)).encode(&quot;base64&quot;).strip()
</code></pre>
<p>首先这很明显是一个base64，但是一开始我并没有发现她们和cid,size,gcid的关系，<del>直到我膝盖中了一箭</del>。。<br>fid就是cid,size,gcid的二进制然后再base64而已。但是有了fid，神马cid,size,gcid这三大要素都不是问题了。应该是用于api分析url的便利，所做的一个接口性参数。</p>
<h2 id="tid"><a href="#tid" class="headerlink" title="tid"></a>tid</h2><p>未知算法。<br>根据18万的文件数据，唯一能够知道的是，这个tid和文件大小一一对应。。size相同的文件tid一定相同，但是又不是size的直接hash，目前来说完全不知道这个参数的意义何在。。<br>如果有兴趣，您可以在<a target="_blank" rel="noopener" href="https://github.com/binux/lixian.xunlei/blob/master/tid.dict">https://github.com/binux/lixian.xunlei/blob/master/tid.dict</a>文件里面找到目前已知的映射。。如果分析出算法了请务必告诉我。</p>
<h2 id="n"><a href="#n" class="headerlink" title="n"></a>n</h2><p>算法源码：</p>
<pre><code>thunder_filename_mask = &quot;6131E45F00000000&quot;.decode(&quot;hex&quot;)
def thunder_filename_encode(filename, encoding=&quot;gbk&quot;):
    if isinstance(filename, unicode):
        filename = filename.encode(encoding)
    result = [&quot;01&quot;, ]
    for i, word in enumerate(filename):
        mask = thunder_filename_mask[i%len(thunder_filename_mask)]
        result.append(&quot;%02X&quot; % (ord(word)^ord(mask)))
    while len(result) % 8 != 1:
        mask = thunder_filename_mask[len(result)%len(thunder_filename_mask)-1]
        result.append(&quot;%02X&quot; % ord(mask))
    return &quot;&quot;.join(result)

def thunder_filename_decode(code, encoding=&quot;gbk&quot;):
    assert code.startswith(&quot;01&quot;)
    result = []
    for i, word in enumerate(code[2:].decode(&quot;hex&quot;)):
        mask = thunder_filename_mask[i%len(thunder_filename_mask)]
        result.append(chr(ord(word)^ord(mask)))
    result = &quot;&quot;.join(result).rstrip(&quot;\0&quot;)
    return result.decode(encoding)
</code></pre>
<p>算法来源于<a target="_blank" rel="noopener" href="https://plus.google.com/109026361274947112731">+Zhang Youfu</a>。简单来说这个参数就是将文件名各位用掩码进行了简单转换而已，中文的编码与最终输出的header中的相同，既编码采用utf8，最终输出的也是utf8，值得指出的是默认的编码是gbk的。迅雷在输出文件名时会截断较长的文件名，但是实际上通过传递完整的n参数，可以无视这个限制。在<a target="_blank" rel="noopener" href="https://github.com/binux/ThunderLixianExporter/blob/master/ThunderLixianExporter.js#L300">binux&#x2F;ThunderLixianExporter</a>还有一个js版本的实现。 </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由上面的分析可见，一个文件的离线地址完全就是根据文件的信息生成的，于是你发现了什么？对了，完全不需要通过迅雷服务器我们就可以生成自己的离线地址！如果这个文件在迅雷服务器上存在，我们可以直接下载回来！（等等，你说n。。那不就是文件名嘛。。我只关心内容。。文件名这种小问题。。）<br>说到做到，<strong>您可以通过<a target="_blank" rel="noopener" href="https://github.com/binux/lixian.xunlei/blob/master/check_file.py">https://github.com/binux/lixian.xunlei/blob/master/check_file.py</a>这个文件直接计算出文件的cid,gcid,fid</strong>，如果可能的话也能计算出tid。<br>然后，把fake_url添加到迅雷软件里面。然后。。就可以直接下载了！可以开启高速通道，可以在快盘秒传，运气好可以开启离线秒传。。。<br>over</p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/xunlei/">xunlei</a>, <a href="/tags/loli-lu/">loli.lu</a>, <a href="/tags/hash/">hash</a>
  </div>

        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="as_sitesearch" value="binux.blog">
  </form>
</div>


  <div class="widget tag about_me">
  <h3 class="title">About Me</h3>
  <ul class="entry">
    
    <li>
      <span class="icon email"></span>
      <a href="mailto:roy@binux.me" target=_blank rel=me>roy@binux.me</a>
    </li>
    

    
    <li>
      <span class="icon github"></span>
      <a href="https://github.com/binux" target=_blank rel=me>github.com/binux</a>
    </li>
    

    
    <li>
      <span class="icon twitter"></span>
      <a href="https://twitter.com/roybinux" target=_blank rel=me>@roybinux</a>
    </li>
    

    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2022/09/cat-planet-bot-part-2-video-capture-and-classification/">猫之城物理钓鱼挂（二）：图像采集以及画面分类</a>
      </li>
    
      <li>
        <a href="/2022/08/cat-planet-bot-part-1-touch-simulation/">猫之城物理钓鱼挂（一）：物理模拟触屏点击</a>
      </li>
    
      <li>
        <a href="/2020/01/home-assistant/">家居自动化</a>
      </li>
    
      <li>
        <a href="/2019/03/zerotier-nat-gateway-and-iptables-debug/">Zerotier Nat 网关出口 和 iptables 调试</a>
      </li>
    
      <li>
        <a href="/2018/10/girls-frontline-ankulua-vision/">少女前线拖尸脚本 和 生成它的可视化工具</a>
      </li>
    
  </ul>
</div>


  <div class="widget tag recent-comments">
  <h3 class="title">近期评论</h3>
  <div class="entry">
    <script type="text/javascript" src="//binux.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=0&amp;avatar_size=32&amp;excerpt_length=50"></script>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2022 Roy Binux
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>



<script>
var disqus_shortname = 'binux';
var disqus_config = function () {
this.page.url = 'https://binux.blog/2012/03/hash_algorithm_of_xunlei/';
this.page.identifier = 'https://binux.blog/2012/03/hash_algorithm_of_xunlei/';
};

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>
