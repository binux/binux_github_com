<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>第 2 页 | Binuxの杂货铺</title>
  <meta name="author" content="Roy Binux">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Binuxの杂货铺"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
    <link rel="alternate" href="/atom.xml" title="Binuxの杂货铺" type="application/atom+xml">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-36392342-1', 'auto');
	ga('send', 'pageview');

</script>


<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Binuxの杂货铺</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/projects">Projects</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article id="post-pyspider-tutorial-level-3-render-with-phantomjs" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2015-01-10T08:00:00.000Z"><a href="/2015/01/pyspider-tutorial-level-3-render-with-phantomjs/">2015-01-10</a></time>
      
      
  
    <h1 class="title"><a href="/2015/01/pyspider-tutorial-level-3-render-with-phantomjs/">pyspider 爬虫教程（三）：使用 PhantomJS 渲染带 JS 的页面</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>英文原文：<a target="_blank" rel="noopener" href="http://docs.pyspider.org/en/latest/tutorial/Render-with-PhantomJS/">http://docs.pyspider.org/en/latest/tutorial/Render-with-PhantomJS/</a></p>
<p>在上两篇教程中，我们学习了怎么从 HTML 中提取信息，也学习了怎么处理一些请求复杂的页面。但是有一些页面，它实在太复杂了，无论是分析 API 请求的地址，还是渲染时进行了加密，让直接抓取请求非常麻烦。这时候就是 <a target="_blank" rel="noopener" href="http://phantomjs.org/">PhantomJS</a> 大显身手的时候了。</p>
<p>在使用 <a target="_blank" rel="noopener" href="http://phantomjs.org/">PhantomJS</a> 之前，你需要安装它（<a target="_blank" rel="noopener" href="http://phantomjs.org/download.html">安装文档</a>）。当你安装了之后，在运行 <code>all</code> 模式的 pyspider 时就会自动启用了。当然，你也可以在 <a target="_blank" rel="noopener" href="http://demo.pyspider.org/">demo.pyspider.org</a> 上尝试。</p>
<h2 id="使用-PhantomJS"><a href="#使用-PhantomJS" class="headerlink" title="使用 PhantomJS"></a>使用 PhantomJS</h2><p>当 pyspider 连上 PhantomJS 代理后，你就能通过在 <code>self.crawl</code> 中添加 <code>fetch_type=&#39;js&#39;</code> 的参数，开启使用 PhantomJS 抓取。例如，在教程二中，我们尝试抓取的 <a target="_blank" rel="noopener" href="http://movie.douban.com/explore">http://movie.douban.com/explore</a> 就可以通过 PhantomJS 直接抓取：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span>(<span class="title class_ inherited__">BaseHandler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_start</span>(<span class="params">self</span>):</span><br><span class="line">        self.crawl(<span class="string">&#x27;http://movie.douban.com/explore&#x27;</span>,</span><br><span class="line">                   fetch_type=<span class="string">&#x27;js&#x27;</span>, callback=self.phantomjs_parser)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">phantomjs_parser</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="keyword">return</span> [&#123;</span><br><span class="line">            <span class="string">&quot;title&quot;</span>: <span class="string">&quot;&quot;</span>.join(</span><br><span class="line">                s <span class="keyword">for</span> s <span class="keyword">in</span> x(<span class="string">&#x27;p&#x27;</span>).contents() <span class="keyword">if</span> <span class="built_in">isinstance</span>(s, basestring)</span><br><span class="line">            ).strip(),</span><br><span class="line">            <span class="string">&quot;rate&quot;</span>: x(<span class="string">&#x27;p strong&#x27;</span>).text(),</span><br><span class="line">            <span class="string">&quot;url&quot;</span>: x.attr.href,</span><br><span class="line">        &#125; <span class="keyword">for</span> x <span class="keyword">in</span> response.doc(<span class="string">&#x27;a.item&#x27;</span>).items()]</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>我在这里使用了一些 PyQuery 的 API，你可以在 <a target="_blank" rel="noopener" href="https://pythonhosted.org/pyquery/api.html">PyQuery complete API</a> 获得完整的 API 手册。</li>
</ul>
</blockquote>
<h2 id="在页面上执行自定义脚本"><a href="#在页面上执行自定义脚本" class="headerlink" title="在页面上执行自定义脚本"></a>在页面上执行自定义脚本</h2><p>你会发现，在上面我们使用 <a target="_blank" rel="noopener" href="http://phantomjs.org/">PhantomJS</a> 抓取的豆瓣热门电影只有 20 条。当你点击『加载更多』时，能获得更多的热门电影。为了获得更多的电影，我们可以使用 <code>self.crawl</code> 的 <code>js_script</code> 参数，在页面上执行一段脚本，点击加载更多：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">on_start</span>(<span class="params">self</span>):</span><br><span class="line">    self.crawl(<span class="string">&#x27;http://movie.douban.com/explore#more&#x27;</span>,</span><br><span class="line">               fetch_type=<span class="string">&#x27;js&#x27;</span>, js_script=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">               function() &#123;</span></span><br><span class="line"><span class="string">                 setTimeout(&quot;$(&#x27;.more&#x27;).click()&quot;, 1000);</span></span><br><span class="line"><span class="string">               &#125;&quot;&quot;&quot;</span>, callback=self.phantomjs_parser)</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>这个脚本默认在页面加载结束后执行，你可以通过 <code>js_run_at</code> <a target="_blank" rel="noopener" href="http://docs.pyspider.org/en/latest//apis/self.crawl/#enable-javascript-fetcher-need-support-by-fetcher">参数</a> 修改这个行为</li>
<li>由于是 AJAX 异步加载的，在页面加载完成时，第一页的电影可能还没有加载完，所以我们用 <code>setTimeout</code> 延迟 1 秒执行。</li>
<li>你可以间隔一定时间，多次点击，这样可以加载更多页。</li>
<li>由于相同 URL （实际是相同 taskid） 的任务会被去重，所以这里为 URL 加了一个 <code>#more</code></li>
</ul>
</blockquote>
<p>上面两个例子，都可以在 <a target="_blank" rel="noopener" href="http://demo.pyspider.org/debug/tutorial_douban_explore">http://demo.pyspider.org/debug/tutorial_douban_explore</a> 中找到。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-pyspider-tutorial-level-2-ajax-and-more-http" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2015-01-09T08:00:00.000Z"><a href="/2015/01/pyspider-tutorial-level-2-ajax-and-more-http/">2015-01-09</a></time>
      
      
  
    <h1 class="title"><a href="/2015/01/pyspider-tutorial-level-2-ajax-and-more-http/">pyspider 爬虫教程（二）：AJAX 和 HTTP</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>在上一篇教程中，我们使用 <code>self.crawl</code> API 抓取豆瓣电影的 HTML 内容，并使用 CSS 选择器解析了一些内容。不过，现在的网站通过使用 <a target="_blank" rel="noopener" href="http://www.w3school.com.cn/ajax/ajax_intro.asp">AJAX</a> 等技术，在你与服务器交互的同时，不用重新加载整个页面。但是，这些交互手段，让抓取变得稍微难了一些：你会发现，这些网页在抓回来后，和浏览器中的并不相同。你需要的信息并不在返回 HTML 代码中。</p>
<p>在这一篇教程中，我们会讨论这些技术 和 抓取他们的方法。（英文版：<a target="_blank" rel="noopener" href="http://docs.pyspider.org/en/latest/tutorial/AJAX-and-more-HTTP/">AJAX-and-more-HTTP</a>）</p>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p><a target="_blank" rel="noopener" href="http://www.w3school.com.cn/ajax/ajax_intro.asp">AJAX</a> 是 Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）的缩写。AJAX 通过使用原有的 web 标准组件，实现了在不重新加载整个页面的情况下，与服务器进行数据交互。例如在新浪微博中，你可以展开一条微博的评论，而不需要重新加载，或者打开一个新的页面。但是这些内容并不是一开始就在页面中的（这样页面就太大了），而是在你点击的时候被加载进来的。这就导致了你抓取这个页面的时候，并不能获得这些评论信息（因为你没有『展开』）。</p>
<p><a target="_blank" rel="noopener" href="http://www.w3school.com.cn/ajax/ajax_intro.asp">AJAX</a> 的一种常见用法是使用 <a target="_blank" rel="noopener" href="http://www.w3school.com.cn/ajax/ajax_intro.asp">AJAX</a> 加载 <a target="_blank" rel="noopener" href="http://www.w3school.com.cn/json/">JSON</a> 数据，然后在浏览器端渲染。如果能直接抓取到 <a target="_blank" rel="noopener" href="http://www.w3school.com.cn/json/">JSON</a> 数据，会比 HTML 更容易解析。</p>
<p>当一个网站使用了 AJAX 的时候，除了用 pyspider 抓取到的页面和浏览器看到的不同以外。你在浏览器中打开这样的页面，或者点击『展开』的时候，常常会看到『加载中』或者类似的图标&#x2F;动画。例如，当你尝试抓取：<a target="_blank" rel="noopener" href="http://movie.douban.com/explore">http://movie.douban.com/explore</a></p>
<p><img src="/assets/image/douban_explore.png" alt="douban explore"></p>
<p>你会发现电影是『载入中…』</p>
<h3 id="找到真实的请求"><a href="#找到真实的请求" class="headerlink" title="找到真实的请求"></a>找到真实的请求</h3><p>由于 AJAX 实际上也是通过 HTTP 传输数据的，所以我们可以通过 <a target="_blank" rel="noopener" href="https://developer.chrome.com/devtools">Chrome Developer Tools</a> 找到真实的请求，直接发起真实请求的抓取就可以获得数据了。</p>
<ol>
<li>打开一个新窗口</li>
<li>按 <code>Ctrl</code>+<code>Shift</code>+<code>I</code> (在 Mac 上请按 <code>Cmd</code>+<code>Opt</code>+<code>I</code>) 打开开发者工具。</li>
<li>切换到网络（ Netwotk 面板）</li>
<li>在窗口中打开 <a target="_blank" rel="noopener" href="http://movie.douban.com/explore">http://movie.douban.com/explore</a></li>
</ol>
<p>在页面加载的过程中，你会在面板中看到所有的资源请求。</p>
<p><img src="/assets/image/douban_explore_network_panel.png" alt="douban explore network panel"></p>
<p>AJAX 一般是通过 <a target="_blank" rel="noopener" href="http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_create.asp">XMLHttpRequest</a> 对象接口发送请求的，XMLHttpRequest 一般被缩写为 XHR。点击网络面板上漏斗形的过滤按钮，过滤出 XHR 请求。挨个查看每个请求，通过访问路径和预览，找到包含信息的请求：<a target="_blank" rel="noopener" href="http://movie.douban.com/j/search_subjects?type=movie&tag=%E7%83%AD%E9%97%A8&sort=recommend&page_limit=20&page_start=0">http://movie.douban.com/j/search_subjects?type&#x3D;movie&amp;tag&#x3D;%E7%83%AD%E9%97%A8&amp;sort&#x3D;recommend&amp;page_limit&#x3D;20&amp;page_start&#x3D;0</a></p>
<p><img src="/assets/image/douban_explore_xhr_preview.png" alt="douban explore xhr preview"></p>
<p>在豆瓣这个例子中，XHR 请求并不多，可以挨个查看来确认。但在 XHR 请求较多的时候，可能需要结合触发动作的时间，请求的路径等信息帮助在大量的请求中找到包含信息的关键请求。这需要抓取或者前端的相关经验。所以，有一个我一直在提的观点，学习抓取的最好方法是：学会写网站。</p>
<p>现在可以在新窗口中打开 <a target="_blank" rel="noopener" href="http://movie.douban.com/j/search_subjects?type=movie&tag=%E7%83%AD%E9%97%A8&sort=recommend&page_limit=20&page_start=0">http://movie.douban.com/j/search_subjects?type&#x3D;movie&amp;tag&#x3D;%E7%83%AD%E9%97%A8&amp;sort&#x3D;recommend&amp;page_limit&#x3D;20&amp;page_start&#x3D;0</a>，你会看到包含电影数据的 <a target="_blank" rel="noopener" href="http://www.w3school.com.cn/json/">JSON</a> 原始数据。推荐安装 <a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc">JSONView</a>（<a target="_blank" rel="noopener" href="http://jsonview.com/">Firfox版</a>）插件，这样可以看到更好看的 JSON 格式，展开折叠列等功能。然后，我们根据 <a target="_blank" rel="noopener" href="http://www.w3school.com.cn/json/">JSON</a> 数据，编写一个提取电影名和评分的脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span>(<span class="title class_ inherited__">BaseHandler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_start</span>(<span class="params">self</span>):</span><br><span class="line">        self.crawl(<span class="string">&#x27;http://movie.douban.com/j/search_subjects?type=movie&amp;tag=%E7%83%AD%E9%97%A8&amp;sort=recommend&amp;page_limit=20&amp;page_start=0&#x27;</span>,</span><br><span class="line">                   callback=self.json_parser)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">json_parser</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="keyword">return</span> [&#123;</span><br><span class="line">            <span class="string">&quot;title&quot;</span>: x[<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">            <span class="string">&quot;rate&quot;</span>: x[<span class="string">&#x27;rate&#x27;</span>],</span><br><span class="line">            <span class="string">&quot;url&quot;</span>: x[<span class="string">&#x27;url&#x27;</span>]</span><br><span class="line">        &#125; <span class="keyword">for</span> x <span class="keyword">in</span> response.json[<span class="string">&#x27;subjects&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>你可以使用 <code>response.json</code> 将结果转为一个 python 的 <code>dict</code> 对象</li>
</ul>
</blockquote>
<p>你可以在 <a target="_blank" rel="noopener" href="http://demo.pyspider.org/debug/tutorial_douban_explore">http://demo.pyspider.org/debug/tutorial_douban_explore</a> 获得完整的代码，并进行调试。脚本中还有一个使用 <a target="_blank" rel="noopener" href="http://phantomjs.org/">PhantomJS</a> 渲染的提取版本，将会在下一篇教程中介绍。</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">HTTP</a> 是用来传输网页内容的协议。在前面的教程中，我们已经通过 <code>self.crawl</code> 接口提交了 URL 进行了抓取。这些抓取就是通过 HTTP 协议传输的。</p>
<p>在抓取过程中，你可能会遇到类似 <code>403 Forbidden</code>，或者需要登录的情况，这时候你就需要正确的 HTTP 参数进行抓取了。</p>
<p>一个典型的 HTTP 请求包如下，这个请求是发往 <a target="_blank" rel="noopener" href="http://example.com/">http://example.com/</a> 的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.45 Safari/537.36</span><br><span class="line">Referer: http://en.wikipedia.org/wiki/Example.com</span><br><span class="line">Accept-Encoding: gzip, deflate, sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8</span><br><span class="line">If-None-Match: <span class="string">&quot;359670651&quot;</span></span><br><span class="line">If-Modified-Since: Fri, 09 Aug 2013 23:54:35 GMT</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>请求的第一行包含 <code>method</code>, <code>path</code> 和 HTTP 协议的版本信息</li>
<li>余下的行被称为 header，是以 <code>key: value</code> 的形式呈现的</li>
<li>如果是 POST 请求，在请求结尾可能还会有 <code>body</code> 内容</li>
</ul>
</blockquote>
<p>你可以通过前面用过的 <a target="_blank" rel="noopener" href="https://developer.chrome.com/devtools">Chrome Developer Tools</a> 工具查看到这些信息：</p>
<p><img src="/assets/image/request-headers.png" alt="request headers"></p>
<p>在大多数时候，使用正确的 <code>method</code>, <code>path</code>, <code>headers</code> 和 <code>body</code> 总是能抓取到你需要的信息的。</p>
<h3 id="HTTP-Method"><a href="#HTTP-Method" class="headerlink" title="HTTP Method"></a>HTTP Method</h3><p><a target="_blank" rel="noopener" href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp">HTTP Method</a> 告诉服务器对 URL 资源期望进行的操作。例如在打开一个 URL 的时候使用的是 GET 方式，而在提交数据的时候一般使用 POST。</p>
<p>TODO： need example here</p>
<h3 id="HTTP-Headers"><a href="#HTTP-Headers" class="headerlink" title="HTTP Headers"></a>HTTP Headers</h3><p>HTTP Headers 是请求所带的一个参数列表，你可以在 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/List_of_HTTP_header_fields">这里</a> 找到完整的常用 Headers 列表。一些常用的需要注意的有：</p>
<h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><p>UA 是标识你使用的浏览器，或抓取程序的一段字符串。pyspider 使用的默认 UA 是 <code>pyspider/VERSION (+http://pyspider.org/)</code>。网站常用这个字符串来区分用户的操作系统和浏览器，以及判断对方是否是爬虫。所以在抓取的时候，常常会对 UA 进行伪装。</p>
<p>在 pyspider 中，你可以通过 <code>self.crawl(URL, headers=&#123;&#39;User-Agent&#39;: &#39;pyspider&#39;&#125;)</code>，或者是 <code>crawl_config = &#123;&#39;headers&#39;: &#123;&#39;User-Agent&#39;: &#39;xxxx&#39;&#125;&#125;</code> 来指定脚本级别的 UA。详细请查看 <a target="_blank" rel="noopener" href="http://docs.pyspider.org/en/latest/apis/self.crawl/#fetch">API 文档</a>。</p>
<h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><p>Referer 用于告诉服务器，你访问的上一个网页是什么。常常被用于防盗链，在抓取图片的时候可能会用到。</p>
<h4 id="X-Requested-With"><a href="#X-Requested-With" class="headerlink" title="X-Requested-With"></a>X-Requested-With</h4><p>当使用 XHR 发送 AJAX 请求时会带上的 Header，常被用于判断是不是 AJAX 请求。例如在 <a target="_blank" rel="noopener" href="http://bbs.byr.cn/">北邮人论坛</a> 中，你需要：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">on_start</span>(<span class="params">self</span>):</span><br><span class="line">    self.crawl(<span class="string">&#x27;http://bbs.byr.cn/board/Python&#x27;</span>,</span><br><span class="line">               headers=&#123;<span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>&#125;,</span><br><span class="line">               callback=self.index_page)</span><br></pre></td></tr></table></figure>

<p>带有 <code>headers=&#123;&#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;&#125;</code> 才能抓取到内容。</p>
<h3 id="HTTP-Cookie"><a href="#HTTP-Cookie" class="headerlink" title="HTTP Cookie"></a>HTTP Cookie</h3><p>虽然 <code>Cookie</code> 只是 HTTP Header 中的一个，但是因为非常重要，但是拿出来说一下。<code>Cookie</code> 被 HTTP 请求用来区分、追踪用户的身份，当你在一个网站登录的时候，就是通过写入 <code>Cookie</code> 字段来记录登录状态的。</p>
<p>当遇到需要登录的网站，你需要通过设置 Cookie 参数，来请求需要登录的内容。Cookie 可以通过开发者工具的请求面板，或者是资源面板中获得。在 pyspider 中，你也可以使用 <code>response.cookies</code> 获得返回的 cookie，并使用 <code>self.crawl(URL, cookie=&#123;&#39;key&#39;: &#39;value&#39;&#125;)</code> 来设置请求的 Cookie 参数。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-pyspider-tutorial-level-1-html-and-css-selector" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2015-01-04T08:00:00.000Z"><a href="/2015/01/pyspider-tutorial-level-1-html-and-css-selector/">2015-01-04</a></time>
      
      
  
    <h1 class="title"><a href="/2015/01/pyspider-tutorial-level-1-html-and-css-selector/">pyspider 爬虫教程（一）：HTML 和 CSS 选择器</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>虽然以前写过 <a target="_blank" rel="noopener" href="http://blog.binux.me/2013/09/howto-crawl-web/">如何抓取WEB页面</a> 和 <a target="_blank" rel="noopener" href="http://blog.binux.me/2014/07/how-to-extract-data-from-web/">如何从 WEB 页面中提取信息</a>。但是感觉还是需要一篇 step by step 的教程，不然没有一个总体的认识。不过，没想到这个教程居然会变成一篇<a target="_blank" rel="noopener" href="http://docs.pyspider.org/en/latest/tutorial/HTML-and-CSS-Selector/">译文</a>，在这个爬虫教程系列文章中，会以实际的例子，由浅入深讨论爬取（抓取和解析）的一些关键问题。</p>
<p>在 教程一 中，我们将要爬取的网站是豆瓣电影：<a target="_blank" rel="noopener" href="http://movie.douban.com/">http://movie.douban.com/</a></p>
<p>你可以在: <a target="_blank" rel="noopener" href="http://demo.pyspider.org/debug/tutorial_douban_movie">http://demo.pyspider.org/debug/tutorial_douban_movie</a> 获得完整的代码，和进行测试。</p>
<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>由于教程是基于 pyspider 的，你可以安装一个 pyspider（<a target="_blank" rel="noopener" href="http://docs.pyspider.org/en/latest/Quickstart/">Quickstart</a>，也可以直接使用 pyspider 的 demo 环境： <a target="_blank" rel="noopener" href="http://demo.pyspider.org/">http://demo.pyspider.org/</a>。</p>
<p>你还应该至少对万维网是什么有一个简单的认识：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91">万维网</a>是一个由许多互相链接的超文本页面（以下简称网页）组成的系统。</li>
<li>网页使用网址（<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6">URL</a>）定位，并链接彼此</li>
<li>网页使用 <a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">HTTP</a> 协议传输</li>
<li>网页使用 <a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/HTML">HTML</a> 描述外观和语义</li>
</ul>
<p>所以，爬网页实际上就是：</p>
<ol>
<li>找到包含我们需要的信息的网址（URL）列表</li>
<li>通过 HTTP 协议把页面下载回来</li>
<li>从页面的 HTML 中解析出需要的信息</li>
<li>找到更多这个的 URL，回到 2 继续</li>
</ol>
<h2 id="选取一个开始网址"><a href="#选取一个开始网址" class="headerlink" title="选取一个开始网址"></a>选取一个开始网址</h2><p>既然我们要爬所有的电影，首先我们需要抓一个电影列表，一个好的列表应该：</p>
<ul>
<li>包含足够多的电影的 URL</li>
<li>通过翻页，可以遍历到所有的电影</li>
<li>一个按照更新时间排序的列表，可以更快抓到最新更新的电影</li>
</ul>
<p>我们在 <a target="_blank" rel="noopener" href="http://movie.douban.com/">http://movie.douban.com/</a> 扫了一遍，发现并没有一个列表能包含所有电影，只能退而求其次，通过抓取分类下的所有的标签列表页，来遍历所有的电影： <a target="_blank" rel="noopener" href="http://movie.douban.com/tag/">http://movie.douban.com/tag/</a> </p>
<h3 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h3><p>在 pyspider 的 dashboard 的右下角，点击 “Create” 按钮</p>
<p><img src="/assets/image/creating_project.png" alt="Creating a project"></p>
<p>替换 <code>on_start</code> 函数的 <code>self.crawl</code> 的 URL：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@every(<span class="params">minutes=<span class="number">24</span> * <span class="number">60</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_start</span>(<span class="params">self</span>):</span><br><span class="line">    self.crawl(<span class="string">&#x27;http://movie.douban.com/tag/&#x27;</span>, callback=self.index_page)</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>self.crawl</code> 告诉 pyspider 抓取指定页面，然后使用 <code>callback</code> 函数对结果进行解析。</li>
<li><a href="(http://docs.pyspider.org/en/latest/apis/@every/)"><code>@every</code></a> 修饰器，表示 <code>on_start</code> 每天会执行一次，这样就能抓到最新的电影了。</li>
</ul>
</blockquote>
<p>点击绿色的 <code>run</code> 执行，你会看到 <code>follows</code> 上面有一个红色的 1，切换到 <code>follows</code> 面板，点击绿色的播放按钮：</p>
<p><img src="/assets/image/run_one_step.png" alt="Run ont step"></p>
<h2 id="Tag-列表页"><a href="#Tag-列表页" class="headerlink" title="Tag 列表页"></a>Tag 列表页</h2><p>在 <a target="_blank" rel="noopener" href="http://movie.douban.com/tag/">tag 列表页</a> 中，我们需要提取出所有的 电影列表页 的 URL。你可能已经发现了，sample handler 已经提取了非常多大的 URL，所有，一种可行的提取列表页 URL 的方法就是用正则从中过滤出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @config(<span class="params">age=<span class="number">10</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">index_page</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> response.doc(<span class="string">&#x27;a[href^=&quot;http&quot;]&#x27;</span>).items():</span><br><span class="line">            <span class="keyword">if</span> re.<span class="keyword">match</span>(<span class="string">&quot;http://movie.douban.com/tag/\w+&quot;</span>, each.attr.href, re.U):</span><br><span class="line">                self.crawl(each.attr.href, callback=self.list_page)</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>由于 电影列表页和 tag列表页长的并不一样，在这里新建了一个 <code>callback</code> 为 <code>self.list_page</code></li>
<li><code>@config(age=10 * 24 * 60 * 60)</code> 在这表示我们认为 10 天内页面有效，不会再次进行更新抓取</li>
</ul>
</blockquote>
<p>由于 pyspider 是纯 Python 环境，你可以使用 Python 强大的内置库，或者你熟悉的第三方库对页面进行解析。不过更推荐使用 CSS选择器。</p>
<h2 id="电影列表页"><a href="#电影列表页" class="headerlink" title="电影列表页"></a>电影列表页</h2><p>再次点击 <code>run</code> 让我们进入一个电影列表页(<code>list_page</code>)。在这个页面中我们需要提取：</p>
<ul>
<li>电影的链接，例如，<a target="_blank" rel="noopener" href="http://movie.douban.com/subject/1292052/">http://movie.douban.com/subject/1292052/</a></li>
<li>下一页的链接，用来翻页</li>
</ul>
<h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>CSS选择器，顾名思义，是 <a target="_blank" rel="noopener" href="http://www.w3school.com.cn/css/css_intro.asp">CSS</a> 用来定位需要设置样式的元素 所使用的表达式。既然前端程序员都使用 CSS选择器 为页面上的不同元素设置样式，我们也可以通过它定位需要的元素。你可以在 <a target="_blank" rel="noopener" href="http://www.w3school.com.cn/cssref/css_selectors.asp">CSS 选择器参考手册</a> 这里学习更多的 CSS选择器 语法。</p>
<p>在 pyspider 中，内置了 <code>response.doc</code> 的 <a target="_blank" rel="noopener" href="https://pythonhosted.org/pyquery/">PyQuery</a> 对象，让你可以使用类似 jQuery 的语法操作 DOM 元素。你可以在 <a target="_blank" rel="noopener" href="https://pythonhosted.org/pyquery/">PyQuery</a> 的页面上找到完整的文档。</p>
<h3 id="CSS-Selector-Helper"><a href="#CSS-Selector-Helper" class="headerlink" title="CSS Selector Helper"></a>CSS Selector Helper</h3><p>在 pyspider 中，还内置了一个 <code>CSS Selector Helper</code>，当你点击页面上的元素的时候，可以帮你生成它的 CSS选择器 表达式。你可以点击 <code>Enable CSS selector helper</code> 按钮，然后切换到 <code>web</code> 页面：</p>
<p><img src="/assets/image/css_selector_helper.png" alt="css selector helper"></p>
<p>开启后，鼠标放在元素上，会被黄色高亮，点击后，所有拥有相同 CSS选择器 表达式的元素会被高亮。表达式会被插入到 python 代码当前光标位置。创建下面的代码，将光标停留在单引号中间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">list_page</span>(<span class="params">self, response</span>):</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> response.doc(<span class="string">&#x27;&#x27;</span>).items():</span><br></pre></td></tr></table></figure>

<p>点击一个电影的链接，CSS选择器 表达式将会插入到你的代码中，如此重复，插入翻页的链接：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">list_page</span>(<span class="params">self, response</span>):</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> response.doc(<span class="string">&#x27;HTML&gt;BODY&gt;DIV#wrapper&gt;DIV#content&gt;DIV.grid-16-8.clearfix&gt;DIV.article&gt;DIV&gt;TABLE TR.item&gt;TD&gt;DIV.pl2&gt;A&#x27;</span>).items():</span><br><span class="line">        self.crawl(each.attr.href, callback=self.detail_page)</span><br><span class="line">    <span class="comment"># 翻页</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> response.doc(<span class="string">&#x27;HTML&gt;BODY&gt;DIV#wrapper&gt;DIV#content&gt;DIV.grid-16-8.clearfix&gt;DIV.article&gt;DIV.paginator&gt;A&#x27;</span>).items():</span><br><span class="line">        self.crawl(each.attr.href, callback=self.list_page)</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>翻页是一个到自己的 <code>callback</code> 回调</li>
</ul>
</blockquote>
<h2 id="电影详情页"><a href="#电影详情页" class="headerlink" title="电影详情页"></a>电影详情页</h2><p>再次点击 <code>run</code>，follow 到详情页。使用 <code>css selector helper</code> 分别添加电影标题，打分和导演：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">detail_page</span>(<span class="params">self, response</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: response.url,</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: response.doc(<span class="string">&#x27;HTML&gt;BODY&gt;DIV#wrapper&gt;DIV#content&gt;H1&gt;SPAN&#x27;</span>).text(),</span><br><span class="line">        <span class="string">&quot;rating&quot;</span>: response.doc(<span class="string">&#x27;HTML&gt;BODY&gt;DIV#wrapper&gt;DIV#content&gt;DIV.grid-16-8.clearfix&gt;DIV.article&gt;DIV.indent.clearfix&gt;DIV.subjectwrap.clearfix&gt;DIV#interest_sectl&gt;DIV.rating_wrap.clearbox&gt;P.rating_self.clearfix&gt;STRONG.ll.rating_num&#x27;</span>).text(),</span><br><span class="line">        <span class="string">&quot;导演&quot;</span>: [x.text() <span class="keyword">for</span> x <span class="keyword">in</span> response.doc(<span class="string">&#x27;a[rel=&quot;v:directedBy&quot;]&#x27;</span>).items()],</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意，你会发现 <code>css selector helper</code> 并不是总是能提取到合适的 CSS选择器 表达式。你可以在 <a target="_blank" rel="noopener" href="https://developer.chrome.com/devtools">Chrome Dev Tools</a> 的帮助下，写一个合适的表达式：</p>
<p><img src="/assets/image/chrome_dev_tools.png" alt="Chrome Dev Tools"></p>
<p>右键点击需要提取的元素，点击审查元素。你并不需要像自动生成的表达式那样写出所有的祖先节点，只要写出那些能区分你不需要的元素的关键节点的属性就可以了。不过这需要抓取和网页前端的经验。所以，学习抓取的最好方法就是学会这个页面&#x2F;网站是怎么写的。</p>
<p>你也可以在 Chrome Dev Tools 的 Javascript Console 中，使用 <code>$$(a[rel=&quot;v:directedBy&quot;])</code> 测试 CSS Selector。</p>
<h2 id="开始抓取"><a href="#开始抓取" class="headerlink" title="开始抓取"></a>开始抓取</h2><ol>
<li>使用 <code>run</code> 单步调试你的代码，对于用一个 <code>callback</code> 最好使用多个页面类型进行测试。<strong>然后保存。</strong></li>
<li>回到 Dashboard，找到你的项目</li>
<li>将 <code>status</code> 修改为 <code>DEBUG</code> 或 <code>RUNNING</code></li>
<li>按 <code>run</code> 按钮</li>
</ol>
<p><img src="/assets/image/pyspider_index_page.png" alt="pyspider index page"></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-porting-to-python-3" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2014-12-21T08:00:00.000Z"><a href="/2014/12/porting-to-python-3/">2014-12-21</a></time>
      
      
  
    <h1 class="title"><a href="/2014/12/porting-to-python-3/">迁移 Python 3</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>使用 Python 3 的呼声一直很高，Python 3 解决了很多 2 中的坑，比如 unicode，在向他们解释为什么 <code>print str</code> 乱码，<code>fp.write(str)</code> 时报错，在什么时候需要 <code>encode</code>，更容易了。</p>
<p>但是由于一开始接触的就是 Python 2，熟悉的包都是 Python 2（我也不确定他们是否支持 Python 3）。公司机器上的 Python 2.7 就算是“最新”版本。于是一直没有升级。不过有一种说法，切换到 Python 3 的最好时机就是现在。-为了庆祝 star 过 3000-，由于见到两次要求支持 Python 3，用一个周末为 pyspider 加入了 Python 3 支持（怎么样，不难吧）。</p>
<p>主要参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/3/howto/pyporting.html">Porting Python 2 Code to Python 3</a></li>
<li><a target="_blank" rel="noopener" href="http://python-future.org/compatible_idioms.html">Cheat Sheet: Writing Python 2-3 compatible code</a></li>
<li><a target="_blank" rel="noopener" href="https://pythonhosted.org/six/">Six: Python 2 and 3 Compatibility Library</a></li>
</ul>
<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>其实 <a target="_blank" rel="noopener" href="https://docs.python.org/3/howto/pyporting.html">Porting Python 2 Code to Python 3</a> 这篇文章是一个非常好的索引，能让你对将要进行的工作有一个整体的把握，同时能提供细节的链接，能让你立即开始工作。而且这一节内容就来自此文的 <a target="_blank" rel="noopener" href="https://docs.python.org/3/howto/pyporting.html#the-short-explanation">The Short Explanation</a> 一节。因为总结得很好，所以就不重复造轮子了。</p>
<p>首先，低版本的 Python 2 与 Python 3 之间的鸿沟太大了，特别是 Python 2.5(含) 以前的版本。要同时兼容他们的代价太大。而 Python 2.6 和 Python 2.7 已经带有部分 Python 3 的特性，这让迁移的代价大大降低了。同时，不建议支持 Python 3.3 以下的 3 字头版本，由于 Python 3 实际上已经 release 6 年了，这些 Python 3.x 版本也比较老了，很多特性还没有，或者包不支持。所以建议跳过他们。</p>
<p>其次，一定要有测试，保证测试足够的代码覆盖。Python 2 到 Python 3 从包改名到语法都有变化，几乎所有的代码都需要有修改。足够的代码覆盖，才能在这样大规模修改中，保证所有功能可用。而 pyspider 正是因为有 86% 的代码覆盖，我能这么快地完成代码迁移。</p>
<p>读一读 Python 2 和 Python 3 有什么不同。这个可以看看 <a target="_blank" rel="noopener" href="https://docs.python.org/3/whatsnew/index.html">What’s New in Python</a>，特别是 <a target="_blank" rel="noopener" href="https://docs.python.org/3/whatsnew/3.0.html">What’s New In Python 3.0</a>。当然也可以找一些中文的文章，这个方面应该还蛮多的。反正最主要的就是大量的包改名，以及 <code>bytes</code>, <code>str</code>, <code>unicode</code> 三者的变化。或者你可以先读一读 <a target="_blank" rel="noopener" href="http://python-future.org/compatible_idioms.html">Cheat Sheet</a>，虽然等下我们还需要它。</p>
<p>好，现在可以来看看你的包依赖是否支持 Python 3 了。并不是 pip 能安装的包就是支持 Python 3 的，可能装上了依旧不能工作。你可以用 <a target="_blank" rel="noopener" href="https://caniusepython3.com/">Can I Use Python 3</a> 检测包是否支持。不过我更推荐 <a target="_blank" rel="noopener" href="https://python3wos.appspot.com/">PYTHON 3 WALL OF SUPERPOWERS</a> （需要翻墙）。不过也不用担心，大部分包都是支持 Python 3 的，如果不支持，一般都会有替代，例如 pika 就可以被 ampq 替换，而 MySQL-python 能被 mysql-connector-python 替代。</p>
<h2 id="第一步——查找替换"><a href="#第一步——查找替换" class="headerlink" title="第一步——查找替换"></a>第一步——查找替换</h2><p>首先我们从大的方向入手，把一些改名了的包和函数处理一下。请打开 <a target="_blank" rel="noopener" href="http://python-future.org/compatible_idioms.html">Cheat Sheet: Writing Python 2-3 compatible code</a> 参照它们一条条进行。在能搜索的地方，使用搜索统一修改，不然挨个文件太慢，而且会忘记的。因为我用的是 six 作为多环境间的桥梁。所以需要同时参考 <a target="_blank" rel="noopener" href="https://pythonhosted.org/six/">six的文档</a>。你可能需要打开两个窗口，同时运行 Python 2 和 Python 3，确认语句在两个环境下都能执行。</p>
<p>在这一步，我做了以下处理：</p>
<ul>
<li>相对导入 - <a target="_blank" rel="noopener" href="http://python-future.org/compatible_idioms.html#imports-relative-to-a-package">Imports relative to a package</a></li>
<li>urlparse &#x2F; urllib 库改名 - <a target="_blank" rel="noopener" href="https://pythonhosted.org/six/#module-six.moves.urllib.parse">six</a></li>
<li>thread 包改名，而且 <code>get_ident</code> 函数不再存在了。将 <code>thread.get_ident()</code> 改为 <code>threading.current_thread().ident</code> <a target="_blank" rel="noopener" href="https://pythonhosted.org/six/#module-six.moves">six</a></li>
<li><code>basestring</code> 类型不再存在，用 <code>six.string_types</code> 代替 <a target="_blank" rel="noopener" href="http://python-future.org/compatible_idioms.html#basestring">sheet</a></li>
<li><code>__metaclass__</code> 不再存在，用 <code>six.add_metaclass</code> 代替 <a target="_blank" rel="noopener" href="http://python-future.org/compatible_idioms.html#metaclasses">sheet</a></li>
<li><code>UserDict.DictMixin</code> 不再存在，用 <code>collections.Mapping</code> 或者 <code>collections.MutableMapping</code> 代替</li>
<li><code>/</code> 现在是真的除法了，也就是说 int &#x2F; int 会得到一个 float，使用 <code>//</code> 获得地板除效果（由于在 python 中，地板除用得少，实际上不改关系不大） <a target="_blank" rel="noopener" href="http://python-future.org/compatible_idioms.html#division">sheet</a></li>
<li><code>StringIO</code> 现在分为 <code>io.BytesIO</code> 和 <code>io.StringIO</code> 视情况使用</li>
<li>print 现在是一个 function 了 <a target="_blank" rel="noopener" href="http://python-future.org/compatible_idioms.html#stringio">sheet</a></li>
<li><code>unicode</code> 关键字不再存在 使用 <code>six.text_type</code> 代替</li>
<li><code>__builtins__</code> 不存在了，<a target="_blank" rel="noopener" href="https://pythonhosted.org/six/#module-six.moves"><code>six.moves.builtins</code></a> <a target="_blank" rel="noopener" href="http://python-future.org/compatible_idioms.html#unicode-text-string-literals">sheet</a></li>
<li><code>reload</code> 改为 <a target="_blank" rel="noopener" href="https://pythonhosted.org/six/#module-six.moves"><code>six.reload_module</code></a></li>
<li>dict 的 <code>keys</code>， <code>items</code>， <code>values</code> 现在都是迭代器了，不返回列表，原来的 <code>iteritems</code>, <code>itervalues</code> 不再存在，使用 <a target="_blank" rel="noopener" href="https://pythonhosted.org/six/#six.iterkeys">six.iterkeys</a> 等函数代替。</li>
<li><code>raise exc_type, exc_value, tb</code> 的形式不再支持，使用 <code>six.reraise(exc_type, exc_value, tb)</code> 代替。</li>
</ul>
<p>其他的例如 try…catch，如果你在 Python 2 中就比较标准地使用 <code>as</code>，那么这时就不用修改了。</p>
<p>另外，如果你和我一样有 str(object) 来获得 object 的文字结果的习惯话，每次写 <code>six.text_type(object)</code> 太长了。可以写一些兼容性函数，然后在整个项目中使用。</p>
<p>注意到这里，我们并没有处理 <code>bytes</code>, <code>string</code>, <code>unicode</code>，请放下他们，我们在下一节处理这些问题。</p>
<h2 id="第二步——处理-unicode"><a href="#第二步——处理-unicode" class="headerlink" title="第二步——处理 unicode"></a>第二步——处理 unicode</h2><p>由于在 Python 3 中，所有的 <code>&#39;text&#39;</code> 都变成 unicode 了，所以你会觉得它会是一个大问题，是否需要给所有的 <code>&#39;text&#39;</code> 加上 <code>u</code> ，或者干脆所有文件都加上 <code>from __future__ import unicode_literals</code>？</p>
<p>实际上，大部分时候不需要。</p>
<p>在 Python 2 中，我们很少有意识地区分 <code>str</code> 和 <code>unicode</code>，对于大部分函数调用来说，给它 <code>str</code> 或者 <code>unicode</code> 都是一样的，因为他们共享大部分行为。但是在 Python 3 中，<code>bytes</code> 和 <code>str</code>(<code>unicode</code>) 却大不一样。例如当你 <code>for c in bytes</code> 时，得到的是一个 <code>int</code> 而不是一个 <code>str</code>。</p>
<p>虽然不做任何修改，<code>&#39;text&#39;</code> 在 Python 2 中，是 <code>str</code>(<code>bytes</code>)，而在 Python 3 中是 <code>str</code>(<code>unicode</code>)。但是提交给函数时，既然 Python 2 的函数同时支持 <code>str</code> 和 <code>unicode</code>，所以没有任何问题。而且，在 Python 2 中，<code>&#39;text&#39;+u&#39;中文&#39;</code> 会自动升级为 <code>unicode</code>，所以，只需要注意在出现中文的地方使用 <code>u&#39;中文&#39;</code> 就好了（即使在 Python 2 中，这也是一个好的习惯）。而 <code>b&#39;bytes&#39;</code> 的场合非常少，更多的是使用 <code>text.encode</code> 进行转换。所以，对于习惯良好的 Python 2 代码来说，是几乎不需要修改的。</p>
<p>除了源代码之中的 unicode 问题，其他主要问题出现在输入输出上。但是，只要遵循：程序中流通的数据，只能是 unicode。数据进来之后必须转换成 unicode 即可。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>运行测试，哪报错改哪就好了。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-introduction-to-pyspider" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2014-11-16T08:00:00.000Z"><a href="/2014/11/introduction-to-pyspider/">2014-11-16</a></time>
      
      
  
    <h1 class="title"><a href="/2014/11/introduction-to-pyspider/">pyspider介绍</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>虽然已经发过一篇<a target="_blank" rel="noopener" href="http://blog.binux.me/2014/02/pyspider-architecture/">架构设计</a>，但是觉得还是有必要发一篇介绍。而且拖了那么久的第二里程碑的commit数已经超过第一个版本了。。</p>
<p>那么由我再次介绍一下 pyspider。</p>
<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>pyspider 来源于以前做的一个垂直搜索引擎使用的爬虫后端。我们需要从200个站点（由于站点失效，不是都同时啦，同时有100+在跑吧）采集数据，并要求在5分钟内将对方网站的更新更新到库中。</p>
<p>所以，灵活的抓取控制是必须的。同时，由于100个站点，每天都可能会有站点失效或者改版，所以需要能够监控模板失效，以及查看抓取状态。</p>
<p>为了达到5分钟更新，我们使用抓取最近更新页上面的最后更新时间，以此来判断页面是否需要再次抓取。</p>
<p>可见，这个项目对于爬虫的监控和调度要求是非常高的。</p>
<h1 id="pyspider-的主要特性"><a href="#pyspider-的主要特性" class="headerlink" title="pyspider 的主要特性"></a>pyspider 的主要特性</h1><ul>
<li>python 脚本控制，可以用任何你喜欢的html解析包（内置 pyquery）</li>
<li>WEB 界面编写调试脚本，起停脚本，监控执行状态，查看活动历史，获取结果产出</li>
<li>支持 MySQL, MongoDB, SQLite</li>
<li>支持抓取 JavaScript 的页面</li>
<li>组件可替换，支持单机&#x2F;分布式部署，支持 Docker 部署</li>
<li>强大的调度控制</li>
</ul>
<p>由于功能太多，更多请参考<a target="_blank" rel="noopener" href="https://github.com/binux/pyspider/wiki/%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97">脚本编写指南</a></p>
<p>感谢 <a target="_blank" rel="noopener" href="https://plus.google.com/u/0/+PhoenixNemo/">+PhoenixNemo</a> 提供的VPS，提供了一个 demo： <a target="_blank" rel="noopener" href="http://demo.pyspider.org/">demo.pyspider.org</a>。无需安装即可体验。</p>
<p><a target="_blank" rel="noopener" href="http://demo.pyspider.org/"><img src="http://ww1.sinaimg.cn/large/7d46d69fjw1emavy6e9gij21kw0uldvy.jpg" alt="demo"></a></p>
<h1 id="脚本样例"><a href="#脚本样例" class="headerlink" title="脚本样例"></a>脚本样例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> libs.base_handler <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span>(<span class="title class_ inherited__">BaseHandler</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    this is a sample handler</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">    @every(<span class="params">minutes=<span class="number">24</span>*<span class="number">60</span>, seconds=<span class="number">0</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_start</span>(<span class="params">self</span>):</span><br><span class="line">        self.crawl(<span class="string">&#x27;http://scrapy.org/&#x27;</span>, callback=self.index_page)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @config(<span class="params">age=<span class="number">10</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">index_page</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> response.doc(<span class="string">&#x27;a[href^=&quot;http://&quot;]&#x27;</span>).items():</span><br><span class="line">            self.crawl(each.attr.href, callback=self.detail_page)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detail_page</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="string">&quot;url&quot;</span>: response.url,</span><br><span class="line">                <span class="string">&quot;title&quot;</span>: response.doc(<span class="string">&#x27;title&#x27;</span>).text(),</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>例如这就是创建任务后默认生成的一个脚本示例。</p>
<ul>
<li>通过 <code>on_start</code> 回调函数，作为爬取的入口点，当点击主面板上的 <code>run</code> 的时候，就是调用这个函数，启动抓取。</li>
<li><code>self.crawl</code> 告诉调度器，我们需要抓取 <code>&#39;http://scrapy.org/&#39;</code> 这个页面，然后使用 <code>callback=self.index_page</code> 这个回调函数进行解析。</li>
<li>所有 <code>return</code> 的内容默认会被捕获到 <code>resultdb</code> 中，可以直接在 WEBUI 上看到。</li>
</ul>
<h1 id="更多特性和文档"><a href="#更多特性和文档" class="headerlink" title="更多特性和文档"></a>更多特性和文档</h1><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/binux/pyspider/wiki">Wiki</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/binux/pyspider/wiki/%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97">快速指南</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/binux/pyspider/wiki/%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97">脚本编写指南</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-introduction-to-qiandao-today" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2014-09-29T07:00:00.000Z"><a href="/2014/09/introduction-to-qiandao-today/">2014-09-29</a></time>
      
      
  
    <h1 class="title"><a href="/2014/09/introduction-to-qiandao-today/">签到 —— qiandao.today 介绍</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://qiandao.today/">qiandao.today</a> 已经上线了一个半月，这篇blog一个半月以前就应该写了。直到我刷了14遍水晶塔没有ROLL到任何装备（不对，我最后通过贪婪ROLL到了！），打了两晚麻将，把把最小胡牌距离大于5（任意更换手牌达到胡牌的最小张数），房子里刷JJ怪之后。我觉得我必须做点什么。。。</p>
<p>好了，不扯蛋了。自动签到是我对于 “如何请求到数据” ，进行请求自动分析的一个尝试（实际是我 <a target="_blank" rel="noopener" href="http://u2.dmhy.org/">U2</a> 因为45天没登录被封了）。通过<strong>浏览器捕获页面请求瀑布流，进行内容&#x2F;请求分析，找出关键请求</strong>。所以，签到这个项目，我就是先从 <a target="_blank" rel="noopener" href="https://qiandao.today/har/edit">HAR编辑器</a> 开始做的。做的时候还玩了一下 <a target="_blank" rel="noopener" href="http://angularjs.org/">angularjs</a>。<del>然后其他部分都是随便写的</del></p>
<p>但是，对于签到来说，哪些请求是必要的，这个请求是怎么组装的（例如 token 参数怎么来），特征不明显。自动分析出来就能直接用的概率太低了，即使是人还得单步测试呢。于是 HAR编辑器 成为编辑和单步调试的辅助。自动分析变成了 “推荐相关请求”。</p>
<ul>
<li>用户部分系统尝试了一下 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a> 进行密码加密。PBKDF2 的优势在于通过随机盐 加 可配置的多轮加密，加大了单个key的运算代价。</li>
<li>模板执行部分通过提取页面信息，和 jinja2 引擎渲染，可以动态地改变请求的 url、header、data 各个部分。</li>
<li>执行断言加上邮件系统，可以检测签到是否成功，在失败的时候给用户发送邮件提醒。</li>
</ul>
<p>本来还想要做互助打码的验证码系统的，但是通过 <a target="_blank" rel="noopener" href="https://plus.google.com/u/0/+%E9%9B%AA%E6%9C%88%E7%A7%8B%E6%B0%B4%E9%85%B1">雪月秋水</a> 的 <a target="_blank" rel="noopener" href="https://github.com/acgotaku/GetCookies">cookie插件</a>，其实大部分只有登录需要验证码，签到并不需要。<del>关键是做这个东西不好玩</del>，于是就算了。</p>
<p>运行了一个半月，目前有11个公开签到模板，400+个签到任务，每天进行300次签到。不过由于担心单IP登录帐号过多被封，只在v2ex做了一次广告，不敢大范围推广。。。</p>
<hr>

<p>以下是面向普通用户的简介：</p>
<ul>
<li>云代签</li>
<li>支持多个网站</li>
<li>失败邮件提醒</li>
<li>自制模板并分享（<a target="_blank" rel="noopener" href="https://github.com/binux/qiandao/blob/master/docs/har-howto.md">文档</a>）</li>
<li>https 传输安全保证</li>
<li>一号一密用户数据加密</li>
<li>开放源码，支持本地执行（提供本地lite版）</li>
</ul>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/binux/qiandao">binux&#x2F;qiandao</a><br>网站: <a target="_blank" rel="noopener" href="https://qiandao.today/">https://qiandao.today</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-how-to-extract-data-from-web" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2014-07-19T07:00:00.000Z"><a href="/2014/07/how-to-extract-data-from-web/">2014-07-19</a></time>
      
      
  
    <h1 class="title"><a href="/2014/07/how-to-extract-data-from-web/">如何从 WEB 页面中提取信息</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>已经五个月没有更新 blog 了，这五个月全身心投入到了两个关于如何从页面上抽取结构化数据的项目上。这也是我加入某厂最主要的原因。其中一个全自动模板生成抽取器，虽然还不完全能够实用，但比1年前效果好太多，同时也让我想明白了一些问题。这都是下文主要讨论的问题。</p>
<p>关于 <a target="_blank" rel="noopener" href="https://github.com/binux/pyspider">pyspider</a> 项目，这几天我也在慢慢填上这延期了3个月的坑，至少完成第二里程碑吧。但缺少实际应用的环境，很多东西是否工作得很好，我也不是很有把握。如果有的话，还是希望支持1-2个实际的抓取项目吧。</p>
<p>而 “如何获得页面&#x2F;数据” 这个问题依旧是我持续关注中，想要去解决的问题。但是，既然某厂的后续解决方案是将所有抓取页面过 webkit 渲染（虽然很多时候渲染不出 或 需要点击动作，代价往往大于直接抓 API），不会有很多精力投入，待我慢慢想想。。</p>
<p>##四种解析模式</p>
<h3 id="xpath-x2F-css选择器-x2F-正则表达式"><a href="#xpath-x2F-css选择器-x2F-正则表达式" class="headerlink" title="xpath &#x2F; css选择器 &#x2F; 正则表达式"></a>xpath &#x2F; css选择器 &#x2F; 正则表达式</h3><p><strong>示例:</strong> <a target="_blank" rel="noopener" href="https://www.kimonolabs.com/">https://www.kimonolabs.com/</a></p>
<p>通过手动、自动、半自动方式，设定需要抽取元素的 <a target="_blank" rel="noopener" href="http://www.w3schools.com/xpath/default.asp">xpath</a>、 <a target="_blank" rel="noopener" href="http://www.w3schools.com/cssref/css_selectors.asp">css选择器</a> 或 正则表达式 进行定位提取的方法（这里需要指出的是，html 并不是正则的，正则表达式可能在部分简单提取时有效，但 <strong>不要用正则表达式进行页面提取</strong>）。其根本思想是提供一种定位元素的规则进行页面抽取。</p>
<p>这个方法被用得最多，好处是有效，嗯。缺陷在于用户需要会 xpath &#x2F; css选择器 &#x2F; 正则语法，虽然有一些工具（例如上面的kimono、chrome的调试工具、pyspider里面的脚本）辅助生成规则，但可能通用性不足 或 区分度不够，选取到不需要的内容。这在大批量抽取时需要大量的高级人力去配置，即使是熟练工也需要5-10分钟配置一个页面（6-8个属性），需要耗费大量精力。</p>
<p>这种抽取方式的一种变形是：将 key 和 value 同时在页面中标出，通过 key 和 value 总是穿插出现的这一假设，省去单独为每个属性设置规则的人力，极大增快标注效率。<br>例如：<a target="_blank" rel="noopener" href="http://movie.douban.com/subject/7054604/">http://movie.douban.com/subject/7054604/</a> 这个页面中的  </p>
<blockquote>
<p>导演: 迈克尔·贝<br>编剧: 伊伦·克鲁格<br>主演: 马克·沃尔伯格…<br>类型: 动作 &#x2F; 科幻 &#x2F; 冒险<br>制片国家&#x2F;地区: 美国 &#x2F; 中国大陆<br>语言: 英语 &#x2F; 汉语普通话 &#x2F; 粤语<br>上映日期: 2014-06-27(美国&#x2F;中国大陆)<br>片长: 166分钟<br>又名: 变形金刚：歼灭世纪(港) &#x2F; 变形金刚4：灭绝时代 &#x2F; 变形金刚4 &#x2F; 变4 &#x2F; Transformers 4<br>IMDb链接: tt2109248  </p>
</blockquote>
<p>导演&#x2F;编剧&#x2F;类型等 属性名 往往拥有相同的 xpath，而值的 xpath 也是独立的几种。他们一定是 key: value 的形式组织的，通过用 key 分割 value 的方式能轻松将所有信息提取出来。</p>
<h3 id="data-highlighter"><a href="#data-highlighter" class="headerlink" title="data highlighter"></a>data highlighter</h3><p><strong>示例:</strong> <a target="_blank" rel="noopener" href="http://googlewebmastercentral.blogspot.com/2012/12/introducing-data-highlighter-for-event.html">http://googlewebmastercentral.blogspot.com/2012/12/introducing-data-highlighter-for-event.html</a></p>
<p>Data Highlighter 的标注方式是：给一系列相似的页面，让用户标出（高亮）每个属性在页面中的位置。通过多个页面的标注信息，寻找每个属性的特征。当然了，这个特征可以是 xpath，也可以是上下文，也有可能是机器学习的特征向量。</p>
<p>Data Hightlighter 通过高亮 <strong>多个页面中相同属性</strong> 进行规则学习，省去了人为设置规则时的学习成本。实践表明，在单一页面模板下，标记2个页面就足以生成规则了。效率远大于手工设置规则。Google Data Highlighter 甚至对文字进行了切分，能在 <code>英语 / 汉语普通话 / 粤语</code> xpath 相同的情况下，分别选出三种语言。是我目前见过的成熟度最高、通用性最好、最简便的数据抽取方式。</p>
<h3 id="micro-data"><a href="#micro-data" class="headerlink" title="micro-data"></a>micro-data</h3><p><strong>示例:</strong> <a target="_blank" rel="noopener" href="http://microformats.org/">http://microformats.org/</a> 以及各大网站</p>
<p>页面属性标记，通过在页面数据元素上增加属性标识，通过开放的标准格式，为数据提取提供便利，例如这是豆瓣的评论数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt; p class=&quot;rating_self clearfix&quot; typeof=&quot;v:Rating&quot;&gt;</span><br><span class="line">  &lt;span class=&quot;ll bigstar35&quot;&gt;&lt;/span&gt;</span><br><span class="line">  &lt;strong class=&quot;ll rating_num&quot; property=&quot;v:average&quot;&gt;6.7&lt;/strong&gt;</span><br><span class="line">  &lt;span property=&quot;v:best&quot; content=&quot;10.0&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p><code>typeof=&quot;v:Rating&quot;</code> 表明这里是 rating 数据，<code>v:best</code> 表明 rating 的最大值。通过开放的 data format 标准，只按照标准抽取，就能得到包含的结构化数据。但是，需要站长的支持，在页面中加入标记才可以。</p>
<p>从广义上讲，主图识别，页面发布时间这样的属性，其实也可以是通过对页面内容进行分析获得的。这与 micro-data 一样，通过元素足够强的特征，对元素的含义进行理解分析。</p>
<h3 id="模板生成与提取"><a href="#模板生成与提取" class="headerlink" title="模板生成与提取"></a>模板生成与提取</h3><p><img src="/assets/image/screenshot_2014-06-17_19.49.40.png" alt="image"></p>
<p>页面模板（wrapper）抽取是基于这样一个假设：结构化页面都是 通过模板 将数据库中的数据 映射成页面的。通过页面分析，得到页面模板，通过模板提取出实际的结构化数据。</p>
<p>例如，我使用过的方法，将多个相似页面放在一起比对，寻找等位节点（具有相同结构或表示相同数据类型的元素），将 DOM树 合并。通过比较不同页面上的同类节点，能够获知页面中哪部分是变化的，哪部分是不变的。变化的部分为数据，不变部分为模板。最后形成如上图所示的模板，页面变化部分被涂黑。这个方法类似于将多张纸叠在一起，透过光去看，就会发现变化的文字部分会比其他部分更黑。</p>
<p>当然了，这个方法也有缺陷，例如：<a target="_blank" rel="noopener" href="http://www.xdowns.com/soft/1/2/2006/Soft_34115.html">页面一</a>，<a target="_blank" rel="noopener" href="http://www.xdowns.com/soft/10/35/2007/Soft_34731.html">页面二</a> 的标题部分，一个是蓝色，一个是绿色，虽然在人类视觉上它们相差不大，但从页面结构上绿色多了一层 <code>&lt;font&gt;</code>，作为算法很难理解，这样的样式表示他们是否有相同的含义，是否有区别。同理左侧推荐的蓝绿相间，即使作为人也很难理解它们有什么区别。</p>
<p>##两个核心问题</p>
<p>总结起来，以上四种解析模式都在尝试解决以下两个问题：</p>
<h3 id="一个元素在说什么"><a href="#一个元素在说什么" class="headerlink" title="一个元素在说什么"></a>一个元素在说什么</h3><p>当你打开一个页面，你怎么知道一个页面在传递什么信息？你怎么知道一个元素是文章的标题？怎么知道一个元素是作者？作为人类，我们可能会看到一个元素的位置是否在页面中间，元素的字体大小、颜色，元素前面是不是有一个 “作者：”，元素内容是否长得像一个人名&#x2F;时间，上下文中这个元素都在讲什么，这篇文章是什么领域，等等。人类可能会有非常多的 <strong>经验知识</strong> ，当看到一个页面的时候能够解读出页面上的信息。</p>
<p>在 “xpath &#x2F; css选择器 &#x2F; 正则表达式” 的解析模式中，这个工作正是人肉去完成的，人去解读这个页面，找到信息所在元素。而在 “data highlighter” 的解析模式中，也需要人在多个页面中进行标注，告诉机器每个属性所在。</p>
<p>但是作为计算机，是否能做到这一点？micro-data 通过开放的格式约定，通过 <code>property</code> 这一个特殊的属性标记告诉计算机一个元素说的是什么。而模板挖掘通过：xpath，元素class，id属性，上下文等特征去挖掘元素的含义。</p>
<p>但是，页面样式结构，在人类在没有足够的知识情况下，也有可能会无法解读，例如我们的爷爷奶奶可能就看不懂网页上说的是什么。同时，正如语言是有二义性的一样，页面结构也会如此，这给计算机去理解，页面说的是什么，带来了巨大的困难。</p>
<h3 id="这个元素和其他的元素有什么区别"><a href="#这个元素和其他的元素有什么区别" class="headerlink" title="这个元素和其他的元素有什么区别"></a>这个元素和其他的元素有什么区别</h3><p>因为，大批量数据抽取是计算机的活，这需要 <strong>准确</strong> 地告诉计算机，你想要抽取的元素是哪一个。在 “xpath &#x2F; css选择器 &#x2F; 正则表达式” 的解析模式中，xpath、css选择器、正则表达式正是对这一信息的描述。选取一个正确的表达式，即涵盖不同页面，又和其他属性有所区分，是一件需要经验和技巧的工作。而 “data highlighter” 将这个工作交给了计算机。“模板生成和套用” 过程中也由计算机分析出了规则。</p>
<p>而对于 “micro-data” 来说，这个问题有些特殊。通过开放的标准格式，程序已经能够了解每个元素在说什么了，那么定位就不再有意义。但是反过来，这又何尝不是一种定位。</p>
<h3 id="结构化解析"><a href="#结构化解析" class="headerlink" title="结构化解析"></a>结构化解析</h3><p>结构化解析实质是计算机对一个页面的理解，无论这种理解是人去创建规则、做出某种约定 还是 机器学习。上面列举的四种解析方式，“xpath &#x2F; css选择器 &#x2F; 正则表达式” 和 “data highlighter” 回答了这个元素和其他的有什么区别。 “micro-data” 利用了一个元素在说什么。而 “模板生成与提取” 同时涉及元素说什么，它在哪。</p>
<p>那么作为结构化解析的究级形态是怎样？我们可以假想一个人，他打开一个页面就能知道上面说的是什么，有什么样的信息，这是人类对于：通过网页获取知识的一种能力，一种方式。计算机也是一样，结构化抽取 就是 计算机从网页中获取知识的过程。“这个元素和其他的元素有什么区别” 终究只是在无法达到：计算机理解 <strong>一个页面在说什么</strong> 的辅助手段。理解 “一个元素在说什么” 乃至 “一个页面在说什么” 我认为是才是其究级形态，而结构化数据也不过是计算机，对于浩瀚互联网信息理解的一种表达罢了。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-pyspider-architecture" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2014-02-28T08:00:00.000Z"><a href="/2014/02/pyspider-architecture/">2014-02-28</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/pyspider-architecture/">pyspider架构设计</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a target="_blank" rel="noopener" href="https://github.com/binux/pyspider">pyspider</a>是我一年多之前做的一个爬虫架构的开源化实现。主要的功能需求是：</p>
<ul>
<li>抓取、更新调度多站点的特定的页面</li>
<li>需要对页面进行结构化信息提取</li>
<li>灵活可扩展，稳定可监控</li>
</ul>
<p>而这也是绝大多数python爬虫的需求 —— 定向抓取，结构化化解析。但是面对结构迥异的各种网站，单一的抓取模式并不一定能满足，灵活的抓取控制是必须的。为了达到这个目的，单纯的配置文件往往不够灵活，于是，通过脚本去控制抓取是我最后的选择。<br>而去重调度，队列，抓取，异常处理，监控等功能作为框架，提供给抓取脚本，并保证灵活性。最后加上web的编辑调试环境，以及web任务监控，即成为了这套框架。</p>
<p>pyspider的设计基础是：<strong>以python脚本驱动的抓取环模型爬虫</strong></p>
<ul>
<li>通过python脚本进行结构化信息的提取，follow链接调度抓取控制，实现最大的灵活性</li>
<li>通过web化的脚本编写、调试环境。web展现调度状态</li>
<li>抓取环模型成熟稳定，模块间相互独立，通过消息队列连接，从单进程到多机分布式灵活拓展</li>
</ul>
<p><del>这与后来在某厂看到的spider系统整体架构上区别不大</del></p>
<p><img src="/assets/image/pyspider.png" alt="pyspider"></p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p><strong>webui</strong></p>
<ul>
<li>web的可视化任务监控</li>
<li>web脚本编写，单步调试</li>
<li>异常捕获、log捕获，print捕获等</li>
</ul>
<p>scheduler</p>
<ul>
<li>任务优先级</li>
<li>周期定时任务</li>
<li>流量控制</li>
<li>基于时间周期 或 前链标签（例如更新时间）的重抓取调度</li>
</ul>
<p>fetcher</p>
<ul>
<li>dataurl支持，用于假抓取模拟传递</li>
<li>method, header, cookie, proxy, etag, last_modified, timeout 等等抓取调度控制</li>
<li><em>可以通过适配类似 <a target="_blank" rel="noopener" href="http://phantomjs.org/">phantomjs</a> 的webkit引擎支持渲染</em></li>
</ul>
<p>processor</p>
<ul>
<li>内置的pyquery，以jQuery解析页面</li>
<li>在脚本中完全控制调度抓取的各项参数</li>
<li>可以向后链传递信息</li>
<li>异常捕获</li>
</ul>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>pyspider的架构主要分为 scheduler（调度器）, fetcher（抓取器）, processor（脚本执行）：</p>
<p><img src="/assets/image/pyspider-arch.png" alt="pyspider-arch"></p>
<ul>
<li><p>各个组件间使用消息队列连接，除了scheduler是单点的，fetcher 和 processor 都是可以多实例分布式部署的。 scheduler 负责整体的调度控制</p>
</li>
<li><p>任务由 scheduler 发起调度，fetcher 抓取网页内容， processor 执行预先编写的python脚本，输出结果或产生新的提链任务（发往 scheduler），形成闭环。</p>
</li>
<li><p>每个脚本可以灵活使用各种python库对页面进行解析，使用框架API控制下一步抓取动作，通过设置回调控制解析动作。</p>
</li>
</ul>
<p><em><strong>注：output部分设计尚未决定，因为希望输出也可以很灵活地进行。现在是在脚本中有一个<code>on_result</code>的回调，在里面可以自行实现结果输出。</strong></em></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-add-blocked-ip-to-route" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2014-01-27T08:00:00.000Z"><a href="/2014/01/add-blocked-ip-to-route/">2014-01-27</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/add-blocked-ip-to-route/">基于封禁IP名单的自动路由</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>年末本来很闲的，一个月把标日初级上看完了；结果前天开始被拉去做一个要求年后第一周上线的的项目。。还是本来是一个部门做的那种。。于是本月的blog只好凑字数了。。</p>
<p><i>翻<del>自动</i>墙</del>路由基本除去apnic的国内ipv4白名单走国内方案，就剩下autoddvpn的封禁ip列表了（透明代理不考虑）。国内ip白名单的问题是，如果要玩外服DOTA，还得手动加上各种游戏的服务器IP，而autoddvpn万年不更新，很多时候根本命中不了。</p>
<p>于是，有了下面这个根据DNS查询记录添加封禁IP记录的方法：</p>
<ul>
<li>Linux环境</li>
<li>有VPN</li>
<li>通过dnsmasq查询DNS，并打开日志</li>
<li>通过匹配gfwlist的域名判断对应ip是否被封禁，然后添加到路由表中</li>
</ul>
<p>通过脚本</p>
<script src="https://gist.github.com/binux/8456129.js"></script>

<p><code>logread -f</code> 可以替换为 <code>tail -f 日志文件</code><br><code>dev pptp-vpn</code> 可以替换为建立VPN的链接的名字</p>
<p>不过，缺陷是。。第一次访问时需要过1分钟左右才能生效。。</p>
<p>另外，这个是福利： <a target="_blank" rel="noopener" href="http://f.binux.me/lifandb.html">lifandb.html</a> 来自 <a target="_blank" rel="noopener" href="https://github.com/youxiachai/lifandb/">github&#x2F;youxiachai&#x2F;lifandb</a> （请用chrome打开，如果安装了adblock-plus请先禁用）</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-2013" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2013-12-29T08:00:00.000Z"><a href="/2013/12/2013/">2013-12-29</a></time>
      
      
  
    <h1 class="title"><a href="/2013/12/2013/">足兆叉虫的2013</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>我是从来不记日子的，这导致我也不知道有些事情是2013年发生的，还是2012年发生的，亦或只是我的臆想。即便如此，2013年也是变化的一年。</p>
<p>跳槽，工资没涨，工作忙了2倍，但经手了更大的系统（虽然设计很渣），更多协调，带小弟，基本达到了初衷，也说不上是好是坏。搬离大学生活圈、一个人住，第一次有家的感觉，虽然依旧一个人。</p>
<p>想学日语，想出国，但完全没有干劲。</p>
<p>依旧是没有理想，没有希望的一年，就这样一觉不起就好了。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/3/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="as_sitesearch" value="binux.blog">
  </form>
</div>


  <div class="widget tag about_me">
  <h3 class="title">About Me</h3>
  <ul class="entry">
    
    <li>
      <span class="icon email"></span>
      <a href="mailto:roy@binux.me" target=_blank rel=me>roy@binux.me</a>
    </li>
    

    
    <li>
      <span class="icon github"></span>
      <a href="https://github.com/binux" target=_blank rel=me>github.com/binux</a>
    </li>
    

    
    <li>
      <span class="icon twitter"></span>
      <a href="https://twitter.com/roybinux" target=_blank rel=me>@roybinux</a>
    </li>
    

    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2022/08/cat-planet-bot-part-1-touch-simulation/">猫之城物理钓鱼挂（一）：物理模拟触屏点击</a>
      </li>
    
      <li>
        <a href="/2020/01/home-assistant/">家居自动化</a>
      </li>
    
      <li>
        <a href="/2019/03/zerotier-nat-gateway-and-iptables-debug/">Zerotier Nat 网关出口 和 iptables 调试</a>
      </li>
    
      <li>
        <a href="/2018/10/girls-frontline-ankulua-vision/">少女前线拖尸脚本 和 生成它的可视化工具</a>
      </li>
    
      <li>
        <a href="/2018/02/us/">2018 新的冒险</a>
      </li>
    
  </ul>
</div>


  <div class="widget tag recent-comments">
  <h3 class="title">近期评论</h3>
  <div class="entry">
    <script type="text/javascript" src="//binux.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=0&amp;avatar_size=32&amp;excerpt_length=50"></script>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2022 Roy Binux
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>



<script>
var disqus_shortname = 'binux';
var disqus_config = function () {
this.page.url = '';
this.page.identifier = '';
};

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = 'https://' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>
